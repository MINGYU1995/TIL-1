# DFS 알고리즘
> **D**epth-**F**irst **S**earch

**그래프**에서 **깊은 부분**을 우선적으로 **탐색**하는 알고리즘이다.
데이터의 갯수가 N개인 경우, O(N)의 시간복잡도를 가진다.

<br>

## 💡 DFS 동작과정
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.

2. 스택의 최상단 노드에 **방문하지 않은 인접 노드**가 있다면, 그 인접노드를 **스택**에 넣고 방문 처리를 한다.   
방문하지 않은 인접노드가 없다면, 스택에서 최상단 노드를 꺼낸다.

3. 2번과정을 더이상 수행할 수 없을 때까지 반복한다.

 

[참고]   
&nbsp; 그래프의 두 노드가 가나선으로 연결되어 있다면 '*두 노드는 인접하다*'라고 표현한다.   
DFS에서 인접한 노드가 여러개 일 수 있다. 그래서 스택에 어떠한 노드부터 방문할 것인지에 대한 기준이 필요하다. 이는 문제마다 다를 수도 있고 순서가 상관없을 수 있다. 현재의 낮은 수부터 방문한다 가정한다.


<img src="https://user-images.githubusercontent.com/70243735/119224475-898a3c00-bb39-11eb-88f7-a338bc817130.png" >

<br>

## 💡 DFS 구현 코드
DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다.   
실제 구현은 스택을 직접 사용하지 않고 **재귀함수**를 이용할 수 있다.
```python
def dfs(graph, n, visited):
  # 현재 노드를 방문처리
  visited[n] = True
  print(n, end='')
  
  # 현재 노드와 인접한 노드를 확인
  for i in graph[n]:
    # 방문하지 않은 노드라면
    if not visited[n]:
      # 재귀호출
      dfs(graph, i, visited)

######## dfs 사용
# 각 노드에 연결된 정보를 2차원 리스트로 표현
graph =[
  [], # 노드번호가 1부터 시작하기 때문에 인덱스 0은 비워둔다
  [2,3,8], # 1번 노드와 인접한 노드 2,3,8
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
]

# 각 노드가 방문된 정보
visited = [False]*(8+1) # 전체 노드갯수 8개+인덱스0
# dfs 호출
dfs(graph, 1, visited)
```
<br>

## 💡 DFS 알고리즘 문제
### Q1. 음료수 얼려 먹기

&nbsp; &nbsp; N*M 크기의 얼음틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려있는 부분끼리 상,하,좌,우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 갯수를 구하는 프로그램을 작성하시오. 

* 입력 조건
    - 첫째줄에 얼음 틀의 세로 길이 N과 가로길이 M이 주어진다.(1<= N,M <= 1000)
    - 둘째줄부터 N+1번째 줄까지 얼음틀의 형태가 주어진다.
    - 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

* 출력 조건
    - 한번에 만들 수 있는 아이스크림의 갯수를 출력한다.

* 입력 예시
    ```
    4 5
    00110
    00011
    11111
    00000
    ```

* 출력 예시
    ```
    3
    ```
 
<br>

### [문제 아이디어]

&nbsp; '상,하,좌,우로 붙어 있는 경우 서로 연결되어있다고 간주한다'에서 DFS를 떠올릴 수 있었다. 동작과정은 다음과 같다.

1. 특정한 지점의 상, 하, 좌, 우를 살펴본 뒤에 값이 0이면서 아직 방문하지 않은 지점이 있다면 해당 지점을 방문한다.

    (=방문하지 않은 인접노드가 있다면 방문한다.)

2. 방문한 지점에서 다시 상, 하, 좌, 우를 살펴보면서 방문을 진행하면, 연결된 모든 지점을 방문할 수 있다.

3. 전체 얼음틀에 대해서 1~2를 반복하며 만들 수 있는 아이스크림의 갯수를 센다.

<br>

### [코드]

구현시, visited 리스트가 굳이 필요하지 않다.   
graph가 0, 1로만 이루어져있기 때문에 이를 visited로 사용할 수 있다.
```python
# 세로n, 가로m
n, m = map(int, input().split())

# 2차원 맵정보 입력받기
graph=[]
for i in range(n):
  graph.append(list( map(int, input()) ))

# dfs로 특정한 방문한 뒤에 인접 노드들도 방문
def dfs(x,y):
  # 주어진 범위를 벗어날시에 종료
  if x<0 or y<0 or x>n-1 or y>m-1:
    return False

  # 방문할 수 있는 노드라면 방문
  if graph[x][y]==0:
    graph[x][y]=1 # 방문처리
  
    # 인접한 노드들(상하좌우)에 대해 반복 수행
    dfs(x-1,y) # 상
    dfs(x+1,y) # 하
    dfs(x,y-1) # 좌
    dfs(x,y+1) # 우
    return True

  return False

# 아이스크림 수 세기
result = 0
for i in range(n):
  for j in range(m):
    # 현재 위치에서 DFS 수행
    # 애초에 1이였거나 방문하여 1이되었거나 범위를 벗어난 경우라면
    # false를 리턴한다.
    # 만약 True라면 이전에 방문하지 않은 새로운 아이스크림이다
    if dfs(i,j) == True:
      result +=1

print(result)
```

<br>

출처 :   
이것이 코딩테스트다(이동빈 저)